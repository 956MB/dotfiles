#!/bin/bash

display_usage() {
    echo "This script stringifies the contents of a directory, including all files and their line numbers."
    echo ""
    echo "Usage: stringify <repo-root-directory> [-e <extension1>,<extension2>,...] [-i <extension1>,<extension2>,...] -n <custom_output_name> [-m]"
    echo ""
    echo "Example: stringify gpui -i rs,toml -n gpui_rs -m"
    echo ""
    echo "Options:"
    echo "  <repo-root-directory>   Directory to stringify (default: current directory)"
    echo "  -e, --exclude           File extensions to exclude (comma-separated, e.g., -e git,log)"
    echo "  -i, --include           File extensions to include (comma-separated, e.g., -i txt,md)"
    echo "  -n, --name              Custom name for the output file (default: <directory>_stringified.txt)"
    echo "  -m, --minify            Minify the output, removing extra whitespace and replacing newlines with '\n'"
    echo "  -h, --help              Display this help message"
}

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    display_usage
    exit 0
fi

REPO_DIR="."
MINIFY=false

append_patterns() {
    IFS=',' read -ra exts <<<"$1"
    for ext in "${exts[@]}"; do
        echo "-o -name \"*.$ext\""
    done
}

include_patterns() {
    local patterns=()
    IFS=',' read -ra exts <<<"$1"
    for ((i = 0; i < ${#exts[@]}; i++)); do
        if [[ $i -eq 0 ]]; then
            patterns+=("-name \"*.${exts[i]}\"")
        else
            patterns+=("-o -name \"*.${exts[i]}\"")
        fi
    done
    echo "${patterns[@]}"
}

DEFAULT_IGNORE=(
    # Version control
    .git .github .svn .hg .bzr
    # Package managers
    node_modules bower_components jspm_packages
    .npm .yarn .pnpm-store
    # Build outputs and caches
    build dist out .build .dist .out
    .cache .tmp .temp target
    '*pycache*' .pytest_cache .mypy_cache .tox
    .gradle .maven
    # IDE and editor files
    .vscode .idea .vs
    .project .settings .classpath
    *.sublime-* *.swp .netrwhist
    # OS generated files
    .DS_Store Thumbs.db desktop.ini
    # Env and config files
    .env .env.* .envrc
    config.* *.config
    # Logs and databases
    logs *.log npm-debug.log*
    *.sqlite *.sqlite3 *.db
    # Binary and media file directories
    bin lib vendor
    assets images img media static
    fonts videos audio docs
    # Backup files
    *~ *.bak *.swp *.swo
    # Compiled source
    *.com *.class *.dll *.exe *.o *.so *.pyc *.pyo
    # Compressed files
    *.7z *.gz *.jar *.rar *.tar *.zip
    # Other common ignore patterns
    .gitignore .gitattributes .gitmodules .gitkeep
    .dockerignore Dockerfile* docker-compose*
    .eslintignore .prettierignore
    .gitlab-ci.yml .travis.yml .circleci
    .editorconfig
    # Additional patterns to match scc behavior
    '*.min.js' '*.min.css'
    'node_modules*' 'vendor*'
    '.history' '.vscode'
    '*.lock' 'package-lock.json' 'yarn.lock'
    # Audio files
    '*.mp3' '*.ogg' '*.wav' '*.flac' '*.aac' '*.m4a'
    # Video files
    '*.mp4' '*.avi' '*.mov' '*.wmv' '*.flv' '*.webm'
    # Image files
    '*.jpg' '*.jpeg' '*.png' '*.gif' '*.bmp' '*.tiff' '*.svg'
    # Document files
    '*.pdf' '*.doc' '*.docx' '*.xls' '*.xlsx' '*.ppt' '*.pptx'
    # Archive files
    '*.iso' '*.dmg'
    # Font files
    '*.ttf' '*.otf' '*.woff' '*.woff2' '*.eot'
    # Binary files
    '*.bin' '*.dat'
)

IMAGE_EXTENSIONS=(gif png jpg jpeg webp avif)

construct_find_cmd() {
    local cmd="find \"$REPO_DIR\""

    cmd+=" \\( -path '*/.*' -o -path '*/.*/*' \\) -prune -o"

    # Add directory ignores
    cmd+=" \\( -name ${DEFAULT_IGNORE[0]}"
    for ignore in "${DEFAULT_IGNORE[@]:1}"; do
        if [[ $ignore == .* || $ignore == \** ]]; then
            # For dot directories and wildcard patterns, use -path to match any level
            cmd+=" -o -path \"*/$ignore\""
        else
            cmd+=" -o -name $ignore"
        fi
    done
    cmd+=" \\) -prune"

    # Add image file ignores
    cmd+=" -o \\( -iname \"*.${IMAGE_EXTENSIONS[0]}\""
    for ext in "${IMAGE_EXTENSIONS[@]:1}"; do
        cmd+=" -o -iname \"*.$ext\""
    done
    cmd+=" \\) -prune"

    # Add file type and print
    if [[ -n $INCLUDE_PATTERNS ]]; then
        cmd+=" -o -type f \\( ${INCLUDE_PATTERNS[*]} \\) -print"
    elif [[ -n $EXCLUDE_PATTERNS ]]; then
        cmd+=" -o -type f ! \\( $EXCLUDE_PATTERNS \\) -print"
    else
        cmd+=" -o -type f -print"
    fi

    echo "$cmd"
}

while [[ "$#" -gt 0 ]]; do
    case $1 in
    -e | --exclude)
        shift
        EXCLUDE_PATTERNS=$(append_patterns "$1")
        shift
        ;;
    -i | --include)
        shift
        INCLUDE_PATTERNS=$(include_patterns "$1")
        shift
        ;;
    -n | --name)
        shift
        CUSTOM_OUTPUT_NAME="$1"
        shift
        ;;
    -m | --minify)
        MINIFY=true
        shift
        ;;
    *)
        REPO_DIR="$1"
        shift
        ;;
    esac
done

TOTAL_FILES=0
TOTAL_LINES=0

echo "Stringifying repository: $REPO_DIR"

REPO_NAME=$(basename "$REPO_DIR")

if [[ -n $CUSTOM_OUTPUT_NAME ]]; then
    OUTPUT_FILE="${CUSTOM_OUTPUT_NAME}.txt"
else
    OUTPUT_FILE="${REPO_NAME}_stringified.txt"
fi

# Add "_mini" to the output file name if minify is enabled
if [ "$MINIFY" = true ]; then
    OUTPUT_FILE="${OUTPUT_FILE%.*}_mini.txt"
fi

if [ ! -d "$REPO_DIR" ]; then
    echo "Directory does not exist: $REPO_DIR"
    exit 1
fi

>"$OUTPUT_FILE"

FIND_CMD=$(construct_find_cmd)

echo "Constructed find command: $FIND_CMD"

if [[ -n $INCLUDE_PATTERNS ]]; then
    included_extensions=$(echo "$INCLUDE_PATTERNS" | sed -E 's/-name "\*\.([^"]+)"/-name:\1/g' | sed 's/-o //g' | tr ' ' '\n' | grep '^-name:' | cut -d':' -f2 | tr '\n' ',' | sed 's/,$//')
    echo "Included file types: $included_extensions"
fi

if [[ -n $EXCLUDE_PATTERNS ]]; then
    excluded_extensions=$(echo "$EXCLUDE_PATTERNS" | sed 's/.*\*\.\(.*\)".*/\1/g' | tr '\n' ', ' | sed 's/, $//')
    echo "Excluded file types: $excluded_extensions"
fi

is_binary() {
    file --mime-encoding "$1" | grep -q binary
}

while IFS= read -r file; do
    if ! is_binary "$file"; then
        echo "FILE: ${file#$REPO_DIR/}" >>"$OUTPUT_FILE"
        file_lines=$(wc -l <"$file")
        awk '{printf "%6d  %s\n", NR, $0}' "$file" >>"$OUTPUT_FILE"
        echo "" >>"$OUTPUT_FILE"
        ((TOTAL_FILES++))
        ((TOTAL_LINES += file_lines))
    fi
done < <(eval "$FIND_CMD")

echo "Output file: $OUTPUT_FILE"
echo "Total files: $TOTAL_FILES"
echo "Total lines: $TOTAL_LINES"

if [ "$MINIFY" = true ]; then
    echo "Minifying output..."
    awk '
    BEGIN { RS="FILE: "; ORS="" }
    NR>1 {
        gsub(/^[ \t]+|[ \t]+$/, "");  # Trim leading/trailing whitespace
        gsub(/\n+/, "\\n");  # Replace newlines with \n
        gsub(/[ \t]+/, " ");  # Replace multiple spaces/tabs with a single space
        print "FILE: " $0 "\\n";
    }
    ' "$OUTPUT_FILE" >"${OUTPUT_FILE}.temp"
    mv "${OUTPUT_FILE}.temp" "$OUTPUT_FILE"
    echo "Minification complete."
fi

TOTAL_CHARS=$(wc -c <"$OUTPUT_FILE")
